#!/usr/bin/env python3

import argparse
import pathlib

def bin2array(var_name: str, data: bytes) -> str:
  # writes the previous line ending after the next line is read
  # so we don't end up with a trailing comma
  write_line_ending = False
  output = f'''
const unsigned char {var_name}[{len(data)}] = {{
'''
  lines = [data[i:i+16] for i in range(0, len(data), 16)]
  for line in lines:
    if write_line_ending:
      output += ',\n'
    line = ','.join([f"0x{byte:02x}" for byte in line])
    output += f'{line}'
    write_line_ending = True
  output += f"}};\n"
  return output

def bin2h(fin: pathlib.Path, fout:pathlib.Path = None):
  '''Generates a C header file from a binary file.'''
  with open(fout, 'w') as output:
    var_name = fin.stem.replace(".", "_").replace(" ", "_")

    with open(fin, 'rb') as input:
      data = input.read()
      output.write(f"""
// Generated by bin2header (python impl)
#pragma once
""")
      output.write(bin2array(var_name, data))


def main(fin: str, fout: str):
  fin = pathlib.Path(fin)
  fout = pathlib.Path(fout)
  bin2h(fin, fout)

if __name__ == "__main__":
  parser = argparse.ArgumentParser(description='Generates a header file from the binary file provided. Outputs to the same file path as the input by default')
  parser.add_argument('fin', metavar='in', type=str,
                      help='Path to the file to convert to a header file')
  parser.add_argument('-o', '--output', type=str,
                      help='(Optional) Path to the directory to output the header file')
  args = parser.parse_args()
  main(args.fin, args.output)
